# Архітектурне рішення 2: Шарова архітектура (Layered Architecture)

## Контекст

Для організації програмної архітектури було обрано патерн **шарової архітектури**.
Ми використовуємо три основні шари: **API**, **Service** та **Domain**.
Це дозволяє чітко розмежувати обов'язки кожного шару та забезпечити розширюваність і підтримку проекту.

## Рішення

У цій архітектурі будуть розділені різні рівні абстракції:

1. **api/** — **Контролери та роутери**.
2. **service/** — **Бізнес-логіка**.
3. **domain/** — **Моделі даних та інтерфейси**.

### Опис шарів:

#### 1. **api/**
- Зберігається:  
  Контролери, які обробляють HTTP-запити, приймають вхідні дані і передають їх в шари сервісів для подальшої обробки. API також відповідає за серіалізацію та десеріалізацію даних.
- Відповідає за:  
  Прийом запитів від користувача, перевірку вхідних даних (наприклад, валідація) і виклик відповідних методів з сервісного шару.
- Забезпечує інтеграцію з користувацьким інтерфейсом через HTTP.

#### 2. **service/**
- Зберігається:  
  Бізнес-логіка програми, яка відповідає за виконання операцій і маніпуляцій з даними. У цьому шарі реалізуються всі основні функціональні можливості програми (CRUD, логіка обробки даних тощо).
- Відповідає за:  
  Обробку запитів, наданих через API, звернення до шарів **domain** і **repository** для маніпуляції з моделями даних, забезпечення бізнес-правил.
- Не повинно містити прямого доступу до бази даних чи іншої інфраструктури — це має робити репозиторій, що знаходиться в шарі **domain**.

#### 3. **domain/**
- Зберігається:  
  Моделі даних, які описують сутності та об'єкти програми. Також можуть бути розміщені інтерфейси для репозиторіїв і агрегатів.
- Відповідає за:  
  Визначення основних даних і сутностей, які використовуються в програмі, а також за інтерфейси для роботи з репозиторіями, що відповідають за доступ до бази даних.
- Це має бути **незалежним** від конкретних технологій (як, наприклад, ORM), тому в доменному шарі не повинно бути залежностей від конкретних реалізацій баз даних.

---

### Напрямок залежностей (зверху вниз)

1. **api/** може звертатися до **service/**, але не навпаки.
2. **service/** може звертатися до **domain/** для доступу до даних або логіки, але **domain/** не залежить від **service/** або **api/**.
3. **api/** не має безпосереднього доступу до бази даних чи зовнішніх сервісів, ці зв'язки повинні бути через **service/** та **domain**.

### Заборонені зв'язки

1. **api/** не може звертатися напряму до бази даних чи інфраструктурних компонентів (наприклад, безпосередньо до SQL чи ORM). Всі операції з даними повинні проходити через **service/** і **domain**.

2. **service/** не повинно звертатися безпосередньо до інтерфейсів або репозиторіїв, що відповідають за доступ до бази даних. Репозиторії та доступ до даних — це відповідальність **domain** шару.

3. **domain** має бути незалежним від технологій (як база даних або API), тому **domain** не повинно мати зовнішніх залежностей, наприклад, безпосередньо до ORM чи інструментів взаємодії з інфраструктурою.

---

## Наслідки

- Вибір шарової архітектури дозволяє чітко розмежувати обов'язки різних компонентів програми. Це полегшує підтримку, розширюваність і тестування кожного шару.
- Кожен шар можна тестувати окремо, а також легко змінювати або оновлювати один шар без великого впливу на інші.
- Забезпечує розподіл відповідальності: API — для прийому запитів, Service — для бізнес-логіки, Domain — для роботи з даними.
- Це також дозволяє відокремити зовнішні залежності (наприклад, бази даних) від логіки програми.

## Статус/Дата

Статус: Прийнято  
Дата: 2025-11-01